# 接口,lambda表达式和内部类

## 接口

接口中所有方法都是public,不必提供关键字.但在实现方法时需要提供.

接口不能提供实例域,不能实现方法.提供实例域和方法应该交给实现接口的类完成.

怎么理解呢?比如说苹果重100g,汽车重1000kg,这两个类之间没有相同的祖先类(好像有,是Object),因为两者差别很大

但是苹果和汽车确实有重量,此时,可以把重量声明为接口,来供不同的类调用实现.

接口不能实例化,但是能够声明接口变量来引用实现了该接口的类对象.

接口也可以使用instanceof判断是否是实现了特定的接口

接口可以被扩展,可以声明常量.接口域中自动设为public static final

类可以实现多个接口.

为什么不抽象类,而使用接口?因为多继承复杂性增加,而且效率变低.所有使用接口来代替多继承.

在java8中可以在接口中增加静态方法.但是接口也可以有伴随类,伴随类实现了相应接口的部分或者所有方法.

默认方法:可以为接口方法提供默认实现,要使用default修饰符
默认方法可以不实现.默认方法的其他作用:假如类库中接口新增了方法,如果该方法是默认方法,则原来的程序不会出错.

解决默认方法冲突:
1.超类优先原则:如果接口和超类中有同样方法,接口中的默认方法被忽略.
2.接口冲突原则:如果接口之间有方法冲突,必须覆盖整个方法解决冲突,需要手动解决冲突.

## 接口示例

## lambda表达式

函数式编程,将代码(方法)当成参数传递.

lambda表达式:代码块,参数,自由变量的值(不在参数中,但是却可以用的变量)

对于只有一个抽象方法的接口,需要这种接口的对象时,可以提供lambda表达式,这种接口称为函数式接口.

方法引用.
Timer t = new Timer(1000, event -> System.out.println(event));
等同于
Timer t = new Timer(1000, System.out::println); 

构造器引用,有点类似方法引用.

作用域:lambda表达式可以捕获外部作用域的值(自由变量),但是只能引用值不会在lambda表达式中改变的变量,而且只能引用外部不会发生改变的变量.

lambda表达式中捕获的变量是最终变量,不会改变.

使用lambda表达式的重点是延迟执行.

要实现函数式接口来处理自己的lambda表达式.

## 内部类

为什么使用内部类?

1.内部类可以访问该类定义所在的作用域中的数据,包括私有数据.
2.内部类可以对同一个包中的其他类隐藏起来
3.当想要定义一个回调函数而不想编写大量代码,使用匿名内部类便捷.

内部类不会被外部类实例化的时候实例化.(有怀疑,不太正确)

内部类中声明的所有静态域必须是final,因为通常指希望一个静态域只有一个实例.对于每个外部对象,会分别有一个单独的内部类实例.

内部类不能有static方法.

局部内部类,也就是在方法内部中的类,它和外部完全隔离,外部完全无法访问.

妈的,内部类老子不管了,我**就没怎么用过,也没怎么见过.

## 代理

代理对于系统程序设计人员来说很重要,暂时不管,跳过.


