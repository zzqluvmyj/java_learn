# 继承和反射

## 继承

一个对象变量可以指示多种实际类型的现象被称为多态.在运行时能够自动选择调用哪个方法的现象是动态绑定.

java中不支持多继承,但是可以使用接口代替.

不能将超类的引用赋值给子类变量.

在子类中定义的和超类签名相同的方法,在子类中的方法会覆盖父类中的方法,但是返回类型不是签名的一部分,`允许子类将覆盖方法的返回类型定义为原返回类型的子类型`.

如果是private方法,static方法,final方法或者构造器,编译器可以准确知道调用哪个方法,这种调用方式成为静态绑定.

覆盖一个方法的时候,子类方法不能低于超类方法的可见性.

final可以修饰类或者域成员,修饰类后无法被继承,所有内部方法自动变为final,如果域成员是final,子类就不能覆盖该方法

将超类的引用赋值给子类变量,必须进行强制类型转换,(子类名)

使用instanceof操作符判断是否是该类型,检查之后再进行转换.转换错误抛出ClassCastException异常

但是应该尽量少用,如果确定是不转换就可以使用的方法,就无需转换,节省资源.

抽象类:
抽象到一定程度会发生无法描述的抽象字段,比如苹果继承水果,但是如果想要得到果核,对水果来说并不是每种水果都有果核,因此无法描述

使用abstract关键字来声明抽象字段,这样就可以不用实现该字段.
包含抽象方法的类必须声明为抽象类.

抽象类可以包含具体数据和具体方法,建议使用通用的域和方法.

扩展抽象类可以定义一部分抽象类方法,或者不定义抽象方法,这样子类也是抽象类.

抽象类无法实例化.但是可以定义抽象类的对象变量,它只能引用非抽象子类的对象.甚至能定义抽象类的构造函数.

受保护访问,如果希望超类中的方法或者变量可以被子类访问,需要声明为proteced

## Object:所有类的超类

如果没有明确指出父类,默认的父类是Object

Object类型的变量可以引用任何类型的对象.

Object中的方法:

1.equals()
> 不仅要测试是否引用同一个对象,还要测试对象的状态是否相同(也就是对象内字段值)
> 具体见Employee.java和Manager.java

2.hashCode()
> 如果重新定义equals方法,必须重写定义hashCode方法
> 
> hashCode方法返回一个整数数值.
> equals和hashCode必须一致,当对象相等时,其hashCode必须一致

3.toString()
> 数组的toString没有语义化,会生成无意义的值,要使用Arrays.toString(str);
> 建立toString方法有助于调试,日志等
> 
> 简单,没有写例子

## 泛型数组列表

ArrayList是采用类型参数的泛型类.

比如ArrayList<Object>

## 对象包装器和装箱

将int转换为对象,称为装箱,这个类称为包装器.对象包装器不可变.而且对象包装器是final,无法被继承

将int和Integer之间可以自动装箱和拆箱.

在方法中,
使用Integer时无法改变变量值,因为该对象不可变.
使用int时也无法改变,因为是按值传递.

要想编写修改参数值的方法,就需要定义持有者类型,IntHolder,BooleanHolder

## 参数数量可变方法

printf接受两个参数,格式字符串和Object[]数组

## 枚举类

> public enuni Size { SMALL, MEDIUM, LARGE, EXTRAJARGE }; 

比较枚举值可以使用==

## 反射

反射库（reflection library) 提供了一个非常丰富且精心设计的工具集， 以便编写能够动 态操纵 Java 代码的程序。这项功能被大量地应用于 JavaBeans 

暂时跳过不多说.




